## JavaScript 数据类型以及 typeof 返回值

```
typeof x   undefined
typeof undefined  undefined
typeof true   boolean
function A() {}
typeof A function
 
const arr = [] 
const obj = {}
typeof arr object
typeof obj object
```

## 如何区分 arr 和 obj

Array.isArray() || instanceof || constructor

Object.prototype.toString.call(obj) ===Object.prototype.toString.call([])

注意：instanceof在判断数组是，即会把数组当做Array类型，又会把数组当做Object类型，都会返回true

## 前端性能优化

减少请求数：合并资源(精灵图)，减少http请求数。

加快请求速度：预解析DNS，减少域名数，CDN分支。

缓存：http请求协议缓存，离线缓存，离线数据缓存(localStorage)。

渲染：js/css优化，服务器渲染，加快顺序。

## JPG和PNG的区别

1.JPG是有损压缩格式，PNG是无损压缩格式

2.JPG图片没有透明背景，PNG有透明背景

## 树和图的遍历方式

数的遍历方式 

前中后序遍历  递归||非递归 非递归用栈

层次遍历(层次遍历可以设一个队列，把元素放在队列里，每次输出队头元素。)

图的遍历方式

DFS BFS

## 数组和链表的区别

数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问任何元素

链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过元素中的指针联系到一起。

数组 遍历方便 插入删除麻烦 链表恰好相反

## ios七层模型

| 物理层 | 数据链路层 | 网络层 | 传输层  | 会话层 | 表示层 | 应用层          |
| ------ | ---------- | ------ | ------- | ------ | ------ | --------------- |
| 比特   | 帧         | IP     | TCP/UDP |        |        | http/web Socket |

## TCP 和 UDP 的区别。

| TCP                                 | UDP                                                  |
| ----------------------------------- | ---------------------------------------------------- |
| 面向连接                            | 面向无连接                                           |
| 提供可靠的服务                      | 提供不可靠的服务                                     |
| 面向字节流                          | 面向报文(没有阻塞控制 应用场景：IP电话 实时视频会议) |
| 首部开销20字节                      | 首部开销8字节                                        |
| 点对点                              | 一对多 多对多                                        |
| TCP的逻辑信道信号是全双工的可靠通信 | UDP则是不可靠的信道                                  |

## HTTP 2.0 新增

二进制协议，多路复用(共享连接)，数据流，信息头压缩，客户端推送。

## HTTP状态码

200 请求成功

301 永久重定向

302 临时重定向

304 not Modified 未修改

400 客户端错误

401 当前身份验证

403 服务器已经得到请求，但是拒绝执行

500 客户端在执行时发生错误，无法完成请求。

## localStorage和Cookie

localStorage和Cookie都可以在同源窗口中访问

localStorage存储大小为5M，Cookie的存储大小为4k

localStorage只要存放到本地只要不删除就一直存在，Cookie有过期时间expries

## Cookie 可能存在的问题，简单介绍 XSS 和 CSRF。

XSS：指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过网站中注入恶意脚本，使之在浏览器上运行，从而盗取用户的信息入Cookie等。

xss的本质是因为恶意网站没有进行过滤，与正常的代码混合在一起了，浏览器没办法辨别哪些脚本是可信的，从而导致恶意代码的执行。

XSS一般分为存储型，反射型和DOM型。

存储型：指的是恶意代码提交到数据库中，当用户请求数据的时，服务器就将其拼接为HTML后返回给用户，从而导致代码的执行。

反射型：指的是攻击者先将含有攻击的代码发送给目标用户，用户打开后，会访问链接对应的服务器，服务器收到链接请求时，会将带有的XSS代码的数据再次发送给用户，此时用户浏览器就会默认执行带有XSS代码的脚本，此时会触发XSS漏洞。

DOM型：指的是xss代码并不需要服务器的参与，触发xss靠的是浏览器的DOM解析，完全是客户端的事情

防范XSS：输入过滤，输出编码，通过设置set-cookie httponly禁止脚本执行cookie。也可以设置只有在https协议下可以发送cookie。



CSRF：指的是跨站请求伪造攻击，攻击者诱惑用户进入一个第三方网站，然后该网站向攻击网站发送跨站请求。如果用户在被攻击网站保留了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF攻击的本质是利用了cookie会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

一般的CSRF攻击类型由三种：

1.GET类型的CRSF攻击，比如一个网站中的一个img标签里面构建一个请求，当用户打开这个页面时就会自动发送提交。

2.POST类型的CRSF攻击，比如说创建一个表单，然后隐藏它，自动提交这个表单。

3.链接类型的CSRF攻击，比如说创建一个表单，然后隐藏它，自动提交这个表单。

CSRF可以用以下几种方法来防护：

1.同源检测的方法，服务器根据http请求头中的origin或者referer信息来判断请求是否为允许访问的站点。

2.使用CSRF Token来进行验证，服务器向用户返回一个随机数Token，当网站再次发送请求的时候，在请求参数中加入服务器端返回的token，然后服务器对这个token进行验证。这种方法解决了使用cookie单一验证的方法，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中所有的请求都添加上这个token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过平衡负载转移到其他的服务器，但是这个服务器的session中没有保存这个token的话，就没有办法验证了。这种情况我们可以通过token构建的方式来解决。

3.使用双重Cookie验证的方式，服务器在用户访问页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户向服务器发送请求的时候，cookie取出这个字符串，添加到URL参数中，然后服务器通过对cookie中的数据进行比较，来进行验证。

4.在设置cookie的时候设置Samesite，限制cookie不能作为第三方使用，从而避免被攻击者利用。Samesite一共有两种模式，一种是严格模式，在严格模式下cookie在任何情况下ia都不能作为第三方Cookie使用，在宽松模式下，cookie可以被请求时GET请求，且会发送页面跳转的请求所使用。

## 跨域解决方案

### 1. jsonp

**1) JSONP原理**

**利用  标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**

**2) JSONP和AJAX对比**

JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）

**3) JSONP优缺点**

JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**

**4) JSONP的实现流程**

- 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。

- 创建一个

  ```
  <script>
  ```

  标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。

  - 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是`show('我不爱你')`。

- 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。

### 2.cors

在服务端设置

Access-control-allow-Origin 允许哪些域名可以访问

Access-control-allow-methods 允许哪些请求方式

### 3.第三方服务器代理

实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。**
代理服务器，需要做以下几个步骤：

- 接受客户端请求 。
- 将请求 转发给服务器。
- 拿到服务器 响应 数据。
- 将 响应 转发给客户端。

## CSS 选择器，优先级

https://blog.csdn.net/henucm/article/details/105680155

## CSS 动画

transition和animation的区别

大部分都是相同，都是随着时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件就可以实行。transition为两帧，从from...to... 而animation可以一帧一帧的通过keyframes。

## flex 布局

flex是css3新增的一种布局方式，我们可以同时设置一个元素的display属性值设置为flex属性值设置为flex从而使它成为一个flex容器，它的所有子元素都成为它的项目。

一个容器默认有两条轴，一个水平轴，一条是与主轴垂直的交叉轴，我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定标签在主轴的排列方式，使用align-items来指定元素在交叉轴的排序方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。

对于一个容器的项目，我们使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当前排序空间有剩余的时候，项目放大比例。还可以使用flex-shrink来指定当前排序空间不足时， 项目缩小比例。

## position 有几个值，absolute 是相对于谁的定位。

absolute ：生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。

fixed：（老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。

relative：生成相对定位的元素，相对于其在普通流中的位置进行定位。

static：默认值。没有定位，元素出现在正常的流中

## ES6 了解什么？

### export和import  

模块化开发

### Promise 

异步编程的一种解决办法

它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。**改变状态的方式只有一种即异步的结果**：如果成功状态由padding——>fulfilled；否则状态由padding——>rejected。无法提供其他方式改变状态。

### 新增声明命令let和const

有块级作用域  不存在变量提升 不存在重复定义 不可能提前使用。

### 模板字符串

用一对反引号(`)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，也可以在字符串中嵌入变量，js表达式或函数，变量、js表达式或函数需要写在${ }中。即完成拼接。

### 箭头函数

特点：箭头函数的this是继承函数所处上下文的this

### Object.keys()方法

获取对象的所有属性名或方法名（不包括原形的内容），返回一个数组。

### Object.assign()

assign方法将多个原对象的属性和方法都合并到了目标对象上面。可以接收多个参数，第一个参数是目标对象，后面的都是源对象。

### for…of 循环

用于对象遍历

### 解构赋值

```js
var [name, pwd, sex]=["小周", "123456", "男"];
console.log(name) //小周
console.log(pwd)//123456
console.log(sex)//男
```

### set数据结构

Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数。

1）属性和方法：

size 数据的长度
add() 添加某个值，返回 Set 结构本身。
delete() 删除某个值，返回一个布尔值，表示删除是否成功。
has() 查找某条数据，返回一个布尔值。
clear() 清除所有成员，没有返回值。

```js
var arr = [1,1,2,2,3];
var s = new Set(arr);
console.log(s);	//{1, 2, 3}
 
console.log(s.size);	//3
console.log(s.add(4));	//{1, 2, 3, 4}
console.log(s.delete(4));	//true
console.log(s.has(4));	//false
s.clear();
```

### 扩展运算符(...)

## 用 promise 完成同时发送两个请求，并在都返回结果后进行处理。

待学习...

## 宏任务和微任务

微任务包括了promise的回调，node中的process.netxTick,对DOM的变量监听。
宏任务包括script脚本的执行，setTimeout,setInterval,setImmediate一类的定时函数，还有如I/O操作，UI渲染等。

js是单线程运行的，在代码执行前，我们将不同函数的执行上下文引入主线程栈中，当遇到一个异步函数我们不是等待其执行完成而是将其挂起，等到异步函数执行完之后放入任务队列中，当主线程执行栈中任务执行完成之后，在去处理任务队列里面的异步函数,任务队列分为宏任务和微任务，先执行微任务(promise DOM的监听)，将微任务取出压到主线程栈中进行执行，当微任务都执行完之后再执行宏任务(定时器函数)

## CommonJS 

CommonJS方案，它通过require来引入模块，通过module.exports定义模块的输出接口。这种模式加载方案是服务器端的解决方法，它是以同步的方式引入模块的，因为在服务器文件都是存储在本地磁盘，所以读取非常块，所以以同步的加载。但是如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更合适。